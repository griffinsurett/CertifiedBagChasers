#!/usr/bin/env node
// scripts/generate-icon-map.mjs
// Scans the project for icon strings and emits src/utils/iconMap.generated.ts
// Only the icons actually found are imported (named imports) to keep bundles tiny.

import { promises as fs } from 'node:fs';
import path from 'node:path';

const projectRoot = process.cwd();
const outputFile = path.join(projectRoot, 'src/utils/iconMap.generated.ts');

// Supported icon libraries, their package path, and component prefix.
// Aliases let authors write either the short or long prefix (e.g., lucide â†’ lu).
const LIBRARIES = {
  lu: { package: 'react-icons/lu', componentPrefix: 'Lu', aliases: ['lucide'] },
  fi: { package: 'react-icons/fi', componentPrefix: 'Fi', aliases: ['feather'] },
  fa: { package: 'react-icons/fa', componentPrefix: 'Fa', aliases: ['font-awesome', 'fas'] },
  ai: { package: 'react-icons/ai', componentPrefix: 'Ai', aliases: [] },
  bi: { package: 'react-icons/bi', componentPrefix: 'Bi', aliases: [] },
  si: { package: 'react-icons/si', componentPrefix: 'Si', aliases: ['simple-icons'] },
  md: { package: 'react-icons/md', componentPrefix: 'Md', aliases: [] }, // Material Design (off by default in scans; see SCANNABLE_PREFIXES)
};

// Prefixes the scanner will search for. We omit "md" to avoid Tailwind breakpoint strings like "md:hidden".
const SCANNABLE_PREFIXES = new Set(['lu', 'lucide', 'fi', 'feather', 'fa', 'fas', 'ai', 'bi', 'si', 'simple-icons']);
const COMMENT_STRIPPERS = [
  /<!--[\s\S]*?-->/g, // HTML comments
  /\/\*[\s\S]*?\*\//g, // block comments
  /\/\/.*$/gm, // line comments
];
const FILE_EXTENSIONS = new Set(['.ts', '.tsx', '.js', '.jsx', '.astro', '.mdx', '.md', '.json']);
const EXCLUDED_DIRS = new Set(['node_modules', '.git', 'dist', '.vercel', '.astro']);

// Utility: kebab/slug to PascalCase (react-icons export casing)
function toPascalCase(str) {
  return str
    .split(/[-_\s]+/)
    .filter(Boolean)
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join('');
}

function buildIconPattern() {
  const prefixes = Array.from(SCANNABLE_PREFIXES).join('|');
  return new RegExp(`['"\`]((?:${prefixes}):[a-z0-9-]+)['"\`]`, 'gi');
}

function stripComments(content) {
  return COMMENT_STRIPPERS.reduce((acc, regex) => acc.replace(regex, ''), content);
}

function normalizePrefix(prefix) {
  const entry = Object.entries(LIBRARIES).find(([, meta]) => meta.aliases.includes(prefix));
  return entry ? entry[0] : prefix;
}

function normalizeIconId(raw) {
  const [prefix, name] = raw.split(':');
  const normalizedPrefix = normalizePrefix(prefix);
  return `${normalizedPrefix}:${name}`;
}

async function collectFiles(dir) {
  const entries = await fs.readdir(dir, { withFileTypes: true });
  const files = [];

  for (const entry of entries) {
    if (EXCLUDED_DIRS.has(entry.name)) continue;
    const fullPath = path.join(dir, entry.name);

    if (entry.isDirectory()) {
      files.push(...(await collectFiles(fullPath)));
      continue;
    }

    if (FILE_EXTENSIONS.has(path.extname(entry.name))) {
      if (path.resolve(fullPath) === path.resolve(outputFile)) continue; // avoid self-inclusion
      files.push(fullPath);
    }
  }

  return files;
}

async function extractIconsFromFile(filePath, iconPattern) {
  const content = await fs.readFile(filePath, 'utf8');
  const cleaned = stripComments(content);
  const matches = new Set();

  for (const match of cleaned.matchAll(iconPattern)) {
    const raw = match[1];
    const iconId = normalizeIconId(raw);
    matches.add(iconId);
  }

  return matches;
}

function buildImports(iconIds) {
  const importsByPackage = new Map();

  for (const iconId of iconIds) {
    const [prefix, name] = iconId.split(':');
    const library = LIBRARIES[prefix];
    if (!library) continue;

    const componentName = `${library.componentPrefix}${toPascalCase(name)}`;
    const pkg = library.package;
    if (!importsByPackage.has(pkg)) importsByPackage.set(pkg, new Set());
    importsByPackage.get(pkg).add(componentName);
  }

  return importsByPackage;
}

function renderFile(importsByPackage, iconIds) {
  const header = `// This file is auto-generated by scripts/generate-icon-map.mjs.\n// Do not edit manually. Run "node scripts/generate-icon-map.mjs" to regenerate.\n\n`;
  const iconTypeImport = `import type { IconType } from 'react-icons';\n`;
  const importLines = Array.from(importsByPackage.entries())
    .map(([pkg, components]) => `import { ${Array.from(components).sort().join(', ')} } from '${pkg}';`)
    .join('\n');

  const iconEntries = Array.from(iconIds)
    .sort()
    .map((iconId) => {
      const [prefix, name] = iconId.split(':');
      const { componentPrefix } = LIBRARIES[prefix];
      const componentName = `${componentPrefix}${toPascalCase(name)}`;
      return `  '${iconId}': ${componentName},`;
    })
    .join('\n');

  return `${header}${iconTypeImport}${importLines}\n\nexport const iconMap = {\n${iconEntries}\n} satisfies Record<string, IconType>;\n\nexport type IconKey = keyof typeof iconMap;\n`;
}

async function main() {
  const iconPattern = buildIconPattern();
  const searchRoots = [path.join(projectRoot, 'src'), path.join(projectRoot, 'content')];
  const iconIds = new Set();

  for (const root of searchRoots) {
    try {
      const files = await collectFiles(root);
      for (const file of files) {
        const matches = await extractIconsFromFile(file, iconPattern);
        matches.forEach((id) => iconIds.add(id));
      }
    } catch (err) {
      // Ignore missing directories (e.g., /content may not exist)
      if (err.code !== 'ENOENT') {
        console.error(`Error scanning ${root}:`, err);
      }
    }
  }

  if (iconIds.size === 0) {
    console.warn('No icons found. iconMap.generated.ts will be empty.');
  }

  const importsByPackage = buildImports(iconIds);
  const fileContent = renderFile(importsByPackage, iconIds);
  await fs.mkdir(path.dirname(outputFile), { recursive: true });
  await fs.writeFile(outputFile, fileContent);
  console.log(`Generated ${outputFile} with ${iconIds.size} icon(s).`);
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
