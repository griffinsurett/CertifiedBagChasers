---
// src/components/ContentRenderer/variants/TestimonialVariant.astro
/**
 * TestimonialVariant - Testimonials in masonry grid
 *
 * Displays text and video testimonials with quotes, ratings, and results.
 * Uses SectionHeading for consistent styling with other CBC sections.
 * Auto-generates video thumbnails at build time using ffmpeg.
 */

import type { BaseVariantProps } from "../ContentRenderer.types";
import SectionHeading from "@/components/SectionHeading.astro";
import TestimonialMasonry from "@/components/LoopTemplates/TestimonialMasonry";
import { getImageUrl } from "@/utils/images";
import { generateVideoPoster } from "@/utils/videoThumbnails";

interface Props extends BaseVariantProps {
  eyebrow?: string;
}

const {
  items = [],
  title,
  heading,
  description,
  className = "",
  id,
  eyebrow = "Success Stories",
} = Astro.props as Props;

// Process heading content
let displayTitle = title;
let highlightedTitle = "";

if (heading && typeof heading === 'object' && 'before' in heading) {
  displayTitle = heading.before || "";
  highlightedTitle = heading.text || "";
} else if (typeof heading === 'string') {
  displayTitle = heading;
}

// Helper to check if item has a specific tag
const hasTag = (item: any, tag: string) => {
  return item.tags?.includes(tag) ?? false;
};

// Auto-detect video orientation from filename (used when aspect isn't explicitly set)
const detectOrientation = (videoPath: string): 'portrait' | 'landscape' | 'square' => {
  const lower = videoPath.toLowerCase();
  if (lower.includes('landscape')) return 'landscape';
  if (lower.includes('square')) return 'square';
  return 'portrait';
};

// Transform items for the masonry component (async for video poster generation)
// Layout rules (matching i75):
// - Videos: portrait (2 rows), landscape (2 cols), square (1x1)
// - Text with "featured" tag: span 2 columns
const transformedItems = await Promise.all(items.map(async (item) => {
  const isVideo = Boolean(item.video);
  const isFeatured = hasTag(item, 'featured');
  const detectedAspect = item.video ? detectOrientation(item.video) : 'portrait';
  const videoAspect = item.videoAspect && item.videoAspect !== 'portrait'
    ? item.videoAspect
    : detectedAspect;

  let spanColumns = false;
  let spanRows = false;

  if (isVideo) {
    if (videoAspect === 'portrait') {
      spanRows = true;
    } else if (videoAspect === 'landscape') {
      spanColumns = true;
    }
  } else if (isFeatured) {
    spanColumns = true;
  }

  const baseProps = {
    id: item.slug,
    name: item.title || "Anonymous",
    role: item.role || "Customer",
    resultsAmount: item.resultsAmount,
    spanColumns,
    spanRows,
    isVideo,
    videoAspect,
  };

  if (isVideo && item.video) {
    let posterUrl = item.videoPoster ? getImageUrl(item.videoPoster, "") : "";

    if (!posterUrl && item.video) {
      try {
        const posterResult = await generateVideoPoster(item.video);
        posterUrl = posterResult.src;
      } catch (error) {
        console.warn(`Failed to generate poster for ${item.video}:`, error);
      }
    }

    if (!posterUrl) {
      const fallbackPoster = item.bannerImage || item.featuredImage;
      posterUrl = fallbackPoster ? getImageUrl(fallbackPoster, "") : "";
    }

    return {
      ...baseProps,
      type: 'video' as const,
      video: item.video,
      poster: posterUrl || undefined,
      centered: true,
    };
  }

  return {
    ...baseProps,
    type: 'text' as const,
    quote: item.content || item.description || "",
    rating: item.rating || 5,
    resultsPeriod: item.resultsPeriod,
  };
}));

// Smart auto-ordering for optimal masonry layout (dense packing handles the rest)
const landscapeVideos = transformedItems.filter(
  (item) => item.isVideo && item.videoAspect === 'landscape'
);
const portraitVideos = transformedItems.filter(
  (item) => item.isVideo && item.videoAspect === 'portrait'
);
const squareVideos = transformedItems.filter(
  (item) => item.isVideo && item.videoAspect === 'square'
);
const featuredText = transformedItems.filter(
  (item) => !item.isVideo && item.spanColumns
);
const regularText = transformedItems.filter(
  (item) => !item.isVideo && !item.spanColumns
);

const masonryItems: typeof transformedItems = [];

masonryItems.push(...landscapeVideos);

const allText = [...featuredText, ...regularText];
const portraitCount = portraitVideos.length;
const textCount = allText.length;

if (portraitCount > 0 && textCount > 0) {
  const textPerVideo = Math.floor(textCount / (portraitCount + 1));
  let textIdx = 0;

  for (let i = 0; i < portraitCount; i++) {
    for (let j = 0; j < textPerVideo && textIdx < textCount; j++) {
      masonryItems.push(allText[textIdx++]);
    }
    masonryItems.push(portraitVideos[i]);
  }

  while (textIdx < textCount) {
    masonryItems.push(allText[textIdx++]);
  }
} else {
  masonryItems.push(...portraitVideos);
  masonryItems.push(...allText);
}

masonryItems.push(...squareVideos);
---

<section id={id} class={`section-base bg-[#080808] ${className}`}>
  <div class="max-w-[1300px] mx-auto">
    <SectionHeading
      eyebrow={eyebrow}
      title={displayTitle}
      highlightedTitle={highlightedTitle}
      description={description}
    />

    {masonryItems.length > 0 && (
      <TestimonialMasonry
        items={masonryItems}
        client:load
      />
    )}
  </div>
</section>
